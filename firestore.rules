/**
 * @fileoverview Firestore Security Rules for the HR application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data
 * (attendance, leave requests, payroll, chat messages) and restricts access
 * to user profiles and associated data to the authenticated user. Top-level
 * collections (candidates, anomalies) are left open for prototyping but MUST
 * be secured appropriately for production.
 *
 * Data Structure:
 * - `/users/{userId}`: Stores public user profile information.
 * - `/users/{userId}/attendance/{attendanceId}`: Attendance records.
 * - `/users/{userId}/leaveRequests/{leaveRequestId}`: Leave requests.
 * - `/users/{userId}/payroll/{payrollId}`: Payroll information.
 * - `/users/{userId}/chatMessages/{chatMessageId}`: Chat messages.
 * - `/candidates/{candidateId}`: Job candidate information.
 * - `/anomalies/{anomalyId}`: Detected anomalies in attendance records.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Users can only read and write data within their own user subcollections.
 * - Listing users is explicitly denied to prevent information disclosure.
 * - Candidate and anomaly data is currently open but MUST be secured in production.
 *
 * Denormalization for Authorization:
 *  - The data structure uses path-based ownership (`/users/{userId}/...`) which implicitly
 *    denormalizes the user ID onto all subcollection documents. This avoids the need for
 *    `get()` calls to verify ownership.
 *
 * Structural Segregation:
 *  - User-specific data (attendance, leave requests, etc.) is stored in user subcollections
 *    while broader data (candidates, anomalies) is stored in top-level collections. This
 *    segregation allows for different access control policies for each type of data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}
     * @allow (get, create, update) if the user is signed in and the userId matches the authenticated user's UID.
     * @deny (create, update, delete) if the user is not signed in or the userId does not match the authenticated user's UID.
     * @principle Enforces document ownership for writes and allows public reads.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn();
      allow list: if false; // Explicitly deny listing of users.

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId); // Enforce immutability of userId
      allow delete: if isSignedIn() && isOwner(userId);

    }

    /**
     * @description Controls access to attendance records for a specific user.
     * @path /users/{userId}/attendance/{attendanceId}
     * @allow (create, update, delete) if the user is the owner of the parent user document.
     * @deny (create, update, delete) if the user is not the owner of the parent user document.
     * @principle Enforces user-based ownership for attendance data.
     */
    match /users/{userId}/attendance/{attendanceId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to leave requests for a specific user.
     * @path /users/{userId}/leaveRequests/{leaveRequestId}
     * @allow (create, update, delete) if the user is the owner of the parent user document.
     * @deny (create, update, delete) if the user is not the owner of the parent user document.
     * @principle Enforces user-based ownership for leave request data.
     */
    match /users/{userId}/leaveRequests/{leaveRequestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to payroll records for a specific user.
     * @path /users/{userId}/payroll/{payrollId}
     * @allow (create, update, delete) if the user is the owner of the parent user document.
     * @deny (create, update, delete) if the user is not the owner of the parent user document.
     * @principle Enforces user-based ownership for payroll data.
     */
    match /users/{userId}/payroll/{payrollId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to chat messages for a specific user.
     * @path /users/{userId}/chatMessages/{chatMessageId}
     * @allow (create, update, delete) if the user is the owner of the parent user document.
     * @deny (create, update, delete) if the user is not the owner of the parent user document.
     * @principle Enforces user-based ownership for chat message data.
     */
    match /users/{userId}/chatMessages/{chatMessageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }

    /**
     * @description Controls access to candidate documents.
     * @path /candidates/{candidateId}
     * @allow get, list: if true; // Open access for prototyping. MUST be secured in production.
     * @deny create, update, delete: if false; // TODO: Add appropriate authorization checks.
     * @principle Placeholder for candidate security rules.
     */
    match /candidates/{candidateId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add appropriate authorization checks.
      allow update: if false; // TODO: Add appropriate authorization checks.
      allow delete: if false; // TODO: Add appropriate authorization checks.
    }

    /**
     * @description Controls access to anomaly documents.
     * @path /anomalies/{anomalyId}
     * @allow get, list: if true; // Open access for prototyping. MUST be secured in production.
     * @deny create, update, delete: if false; // TODO: Add appropriate authorization checks.
     * @principle Placeholder for anomaly security rules.
     */
    match /anomalies/{anomalyId} {
      allow get: if true;
      allow list: if true;
      allow create: if false; // TODO: Add appropriate authorization checks.
      allow update: if false; // TODO: Add appropriate authorization checks.
      allow delete: if false; // TODO: Add appropriate authorization checks.
    }
  }
}