/**
 * @description This ruleset enforces a strict user-ownership model for employee-related data,
 *              while allowing open read access to top-level collections like 'candidates' and 'anomalies'.
 *              Employee data is nested under `/employees/{employeeId}`, enabling path-based authorization.
 *
 * @dataStructure
 *   /employees/{employeeId} (Employee profile)
 *   /employees/{employeeId}/attendance/{attendanceId} (Attendance records)
 *   /employees/{employeeId}/leaveRequests/{leaveRequestId} (Leave requests)
 *   /employees/{employeeId}/payroll/{payrollId} (Payroll information)
 *   /employees/{employeeId}/chatMessages/{chatMessageId} (Chat messages)
 *   /candidates/{candidateId} (Job candidate profiles)
 *   /anomalies/{anomalyId} (Detected anomalies)
 *
 * @keySecurityDecisions
 *   - Read access to employee subcollections (attendance, leave requests, payroll, chat messages) is restricted to the employee.
 *   - Top-level collections 'candidates' and 'anomalies' are publicly readable, but only authenticated users can create, update, or delete.
 *   - Data validation is limited to ensuring ownership consistency and preventing changes to critical relational fields.
 *
 * @denormalizationForAuthorization Path-based ownership is used extensively to avoid `get()` calls.
 *                              For example, attendance records are stored under `/employees/{employeeId}/attendance/{attendanceId}`
 *                              so that checking ownership is simply `isOwner(employeeId)`.
 *
 * @structuralSegregation Private employee data is stored under `/employees/{employeeId}`, while potentially public data
 *                        (candidates, anomalies) are stored in top-level collections, enabling different access control policies.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages employee profiles. Only authenticated users can create, update, or delete employee profiles.
     * @path /employees/{employeeId}
     * @allow (create) request.auth != null && request.resource.data.id == request.auth.uid
     * @allow (get, list) true
     * @deny (create) request.auth == null
     * @deny (update) !isExistingOwner(employeeId)
     * @deny (delete) !isExistingOwner(employeeId)
     * @principle Enforces document ownership for writes and allows public reads.
     */
    match /employees/{employeeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.id == employeeId;
      allow update: if isExistingOwner(employeeId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages attendance records for each employee. Only the employee can create, update, or delete their own attendance records.
     * @path /employees/{employeeId}/attendance/{attendanceId}
     * @allow (create) request.auth != null && isOwner(employeeId)
     * @allow (get, list) isOwner(employeeId)
     * @deny (create) !isOwner(employeeId)
     * @deny (update) !isExistingOwner(employeeId)
     * @deny (delete) !isExistingOwner(employeeId)
     * @principle Enforces document ownership for all operations.
     */
    match /employees/{employeeId}/attendance/{attendanceId} {
      allow get, list: if isOwner(employeeId);
      allow create: if isSignedIn() && isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages leave requests submitted by each employee. Only the employee can create, update, or delete their own leave requests.
     * @path /employees/{employeeId}/leaveRequests/{leaveRequestId}
     * @allow (create) request.auth != null && isOwner(employeeId)
     * @allow (get, list) isOwner(employeeId)
     * @deny (create) !isOwner(employeeId)
     * @deny (update) !isExistingOwner(employeeId)
     * @deny (delete) !isExistingOwner(employeeId)
     * @principle Enforces document ownership for all operations.
     */
    match /employees/{employeeId}/leaveRequests/{leaveRequestId} {
      allow get, list: if isOwner(employeeId);
      allow create: if isSignedIn() && isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages payroll information for each employee. Only the employee can create, update, or delete their own payroll information.
     * @path /employees/{employeeId}/payroll/{payrollId}
     * @allow (create) request.auth != null && isOwner(employeeId)
     * @allow (get, list) isOwner(employeeId)
     * @deny (create) !isOwner(employeeId)
     * @deny (update) !isExistingOwner(employeeId)
     * @deny (delete) !isExistingOwner(employeeId)
     * @principle Enforces document ownership for all operations.
     */
    match /employees/{employeeId}/payroll/{payrollId} {
      allow get, list: if isOwner(employeeId);
      allow create: if isSignedIn() && isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages chat messages for each employee. Only the employee can create, update, or delete their own chat messages.
     * @path /employees/{employeeId}/chatMessages/{chatMessageId}
     * @allow (create) request.auth != null && isOwner(employeeId)
     * @allow (get, list) isOwner(employeeId)
     * @deny (create) !isOwner(employeeId)
     * @deny (update) !isExistingOwner(employeeId)
     * @deny (delete) !isExistingOwner(employeeId)
     * @principle Enforces document ownership for all operations.
     */
    match /employees/{employeeId}/chatMessages/{chatMessageId} {
      allow get, list: if isOwner(employeeId);
      allow create: if isSignedIn() && isOwner(employeeId);
      allow update: if isExistingOwner(employeeId);
      allow delete: if isExistingOwner(employeeId);
    }

    /**
     * @description Manages job candidates in the recruitment process.  Allows public read access, but restricts writes to authenticated users.
     * @path /candidates/{candidateId}
     * @allow (create) request.auth != null
     * @allow (get, list) true
     * @deny (create) request.auth == null
     * @deny (update) !isSignedIn()
     * @deny (delete) !isSignedIn()
     * @principle Allows public reads with authenticated writes.
     */
    match /candidates/{candidateId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    /**
     * @description Manages detected anomalies in attendance records. Allows public read access, but restricts writes to authenticated users.
     * @path /anomalies/{anomalyId}
     * @allow (create) request.auth != null
     * @allow (get, list) true
     * @deny (create) request.auth == null
     * @deny (update) !isSignedIn()
     * @deny (delete) !isSignedIn()
     * @principle Allows public reads with authenticated writes.
     */
    match /anomalies/{anomalyId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update: if isSignedIn();
      allow delete: if isSignedIn();
    }

    // ===== Helper functions =====

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}