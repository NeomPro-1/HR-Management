/**
 * @fileoverview Firestore Security Rules for the HR and Payroll application.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for employee-related data
 * (attendance, leave requests, payroll, chat messages).  Each employee can only
 * access their own data. Candidates and anomalies are stored in root-level
 * collections with open read access and restricted write access.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information.
 * - /users/{userId}/attendance/{attendanceId}: Stores attendance records.
 * - /users/{userId}/leaveRequests/{leaveRequestId}: Stores leave requests.
 * - /users/{userId}/payroll/{payrollId}: Stores payroll information.
 * - /users/{userId}/chatMessages/{chatMessageId}: Stores chat messages.
 * - /candidates/{candidateId}: Stores job candidate information.
 * - /anomalies/{anomalyId}: Stores detected anomalies in attendance records.
 *
 * Key Security Decisions:
 * - Users can only create, read, update, and delete their own data within their
 *   respective subcollections under /users/{userId}.
 * - Listing of all users is implicitly denied due to the absence of a top-level
 *   `users` collection and the structure focusing on user-owned subcollections.
 * - Top-level collections like `candidates` and `anomalies` are publicly readable,
 *   but writes are restricted (currently disabled).
 *
 * Denormalization for Authorization:
 *  - The data model relies on path-based authorization, where the `userId` in the
 *    path is used to determine ownership. This avoids the need for `get()` calls
 *    to verify ownership.
 *
 * Structural Segregation:
 *  - Private user data is stored under `/users/{userId}`, while potentially public
 *    data (candidates, anomalies) is stored in top-level collections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces read and write access to user profile data, ensuring only the owner can modify it.
     * @path /users/{userId}
     * @allow (create) User with UID 'user123' can create their profile at /users/user123.
     * @allow (get) User with UID 'user123' can read their profile at /users/user123.
     * @deny (create) User with UID 'user456' cannot create a profile at /users/user123.
     * @deny (update) User with UID 'user456' cannot update the profile at /users/user123.
     * @deny (delete) User with UID 'user456' cannot delete the profile at /users/user123.
     * @principle Enforces document ownership for writes and allows owner to read.
     */
    match /users/{userId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false; // Listing all users is not permitted

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.email == request.auth.token.email;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.email == request.auth.token.email;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.email == request.auth.token.email;
    }

    /**
     * @description Enforces read and write access to attendance records, ensuring only the owner can modify their own records.
     * @path /users/{userId}/attendance/{attendanceId}
     * @allow (create) User with UID 'user123' can create an attendance record at /users/user123/attendance/att1.
     * @allow (get) User with UID 'user123' can read their attendance record at /users/user123/attendance/att1.
     * @deny (create) User with UID 'user456' cannot create an attendance record at /users/user123/attendance/att1.
     * @deny (update) User with UID 'user456' cannot update the attendance record at /users/user123/attendance/att1.
     * @deny (delete) User with UID 'user456' cannot delete the attendance record at /users/user123/attendance/att1.
     * @principle Enforces document ownership for writes and allows owner to read.
     */
    match /users/{userId}/attendance/{attendanceId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.employeeId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.employeeId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.employeeId == userId;
    }

    /**
     * @description Enforces read and write access to leave requests, ensuring only the owner can manage their own requests.
     * @path /users/{userId}/leaveRequests/{leaveRequestId}
     * @allow (create) User with UID 'user123' can create a leave request at /users/user123/leaveRequests/leave1.
     * @allow (get) User with UID 'user123' can read their leave request at /users/user123/leaveRequests/leave1.
     * @deny (create) User with UID 'user456' cannot create a leave request at /users/user123/leaveRequests/leave1.
     * @deny (update) User with UID 'user456' cannot update the leave request at /users/user123/leaveRequests/leave1.
     * @deny (delete) User with UID 'user456' cannot delete the leave request at /users/user123/leaveRequests/leave1.
     * @principle Enforces document ownership for writes and allows owner to read.
     */
    match /users/{userId}/leaveRequests/{leaveRequestId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.employeeId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.employeeId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.employeeId == userId;
    }

    /**
     * @description Enforces read and write access to payroll information, ensuring only the owner can view their own payroll data.
     * @path /users/{userId}/payroll/{payrollId}
     * @allow (create) User with UID 'user123' can create a payroll record at /users/user123/payroll/payroll1.
     * @allow (get) User with UID 'user123' can read their payroll record at /users/user123/payroll/payroll1.
     * @deny (create) User with UID 'user456' cannot create a payroll record at /users/user123/payroll/payroll1.
     * @deny (update) User with UID 'user456' cannot update the payroll record at /users/user123/payroll/payroll1.
     * @deny (delete) User with UID 'user456' cannot delete the payroll record at /users/user123/payroll/payroll1.
     * @principle Enforces document ownership for writes and allows owner to read.
     */
    match /users/{userId}/payroll/{payrollId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.employeeId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.employeeId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.employeeId == userId;
    }

    /**
     * @description Enforces read and write access to chat messages, ensuring only the owner can view their own messages.
     * @path /users/{userId}/chatMessages/{chatMessageId}
     * @allow (create) User with UID 'user123' can create a chat message at /users/user123/chatMessages/msg1.
     * @allow (get) User with UID 'user123' can read their chat message at /users/user123/chatMessages/msg1.
     * @deny (create) User with UID 'user456' cannot create a chat message at /users/user123/chatMessages/msg1.
     * @deny (update) User with UID 'user456' cannot update the chat message at /users/user123/chatMessages/msg1.
     * @deny (delete) User with UID 'user456' cannot delete the chat message at /users/user123/chatMessages/msg1.
     * @principle Enforces document ownership for writes and allows owner to read.
     */
    match /users/{userId}/chatMessages/{chatMessageId} {
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);

      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.employeeId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.employeeId == userId;
      allow delete: if isSignedIn() && isExistingOwner(userId) && resource.data.employeeId == userId;
    }

    /**
     * @description Allows public read access to candidate information, but restricts writes.
     * @path /candidates/{candidateId}
     * @allow (get) Any user can read a candidate's information.
     * @allow (list) Any user can list candidates.
     * @deny (create) No one can create candidate documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (update) No one can update candidate documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (delete) No one can delete candidate documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Allows public read access with restricted writes (currently disabled due to missing ownership).
     */
    match /candidates/{candidateId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows public read access to anomaly information, but restricts writes.
     * @path /anomalies/{anomalyId}
     * @allow (get) Any user can read anomaly information.
     * @allow (list) Any user can list anomalies.
     * @deny (create) No one can create anomaly documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (update) No one can update anomaly documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @deny (delete) No one can delete anomaly documents without proper authorization. // TODO: Add owner validation once the schema is updated with an ownership field.
     * @principle Allows public read access with restricted writes (currently disabled due to missing ownership).
     */
    match /anomalies/{anomalyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }

  // Helper function to determine if the user is signed in
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the resource
  function isOwner(userId) {
    return request.auth.uid == userId;
  }

    // Helper function to determine if the user is the owner of the resource, and the resource exists (for update/delete)
  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}