/**
 * @fileoverview Firestore Security Rules for the HR Management System.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal HR data
 * (attendance, leave requests, payroll, chat messages).  Each user can only
 * access their own data. Candidate and anomaly data are stored in top-level
 * collections with public read access but restricted write access.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information.
 * - /users/{userId}/attendance/{attendanceId}: Stores attendance records.
 * - /users/{userId}/leaveRequests/{leaveRequestId}: Stores leave requests.
 * - /users/{userId}/payroll/{payrollId}: Stores payroll information.
 * - /users/{userId}/chatMessages/{chatMessageId}: Stores chat messages.
 * - /candidates/{candidateId}: Stores job candidate information.
 * - /anomalies/{anomalyId}: Stores detected anomalies in attendance records.
 *
 * Key Security Decisions:
 * - User Profiles (/users/{userId}): Users can only read and write their own
 *   profile data.  Listing all users is disallowed to prevent data scraping.
 * - User-Owned Subcollections: Access to attendance, leave requests, payroll,
 *   and chat messages is restricted to the owning user.
 * - Candidates and Anomalies: These collections are publicly readable but
 *   require authentication to modify. Since no ownership field is defined
 *   for the `Candidate` and `Anomaly` entities, write access is temporarily
 *   disabled.
 *
 * Denormalization for Authorization:
 * Path-based ownership is used extensively to avoid the need for `get()` calls
 * in security rules. For example, attendance records are stored under
 * `/users/{userId}/attendance/{attendanceId}`, making it easy to verify
 * ownership using the `userId` path parameter.
 *
 * Structural Segregation:
 * Public data (candidates, anomalies) is stored in top-level collections to
 * allow for public read access without compromising the security of private
 * user data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages user profile data.
     * @path /users/{userId}
     * @allow (create) User oCZzCwBTCyZnmpizN4MZxILbVm13 can create their profile at /users/oCZzCwBTCyZnmpizN4MZxILbVm13
     * @allow (get, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 can get, update, and delete their profile at /users/oCZzCwBTCyZnmpizN4MZxILbVm13
     * @deny (create) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot create a profile for another user at /users/someOtherUserId
     * @deny (get, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot get, update, and delete another user's profile at /users/someOtherUserId
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages attendance records for a user.
     * @path /users/{userId}/attendance/{attendanceId}
     * @allow (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 can manage their own attendance records under /users/oCZzCwBTCyZnmpizN4MZxILbVm13/attendance/{attendanceId}
     * @deny (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot manage another user's attendance records under /users/someOtherUserId/attendance/{attendanceId}
     * @principle Enforces document ownership and restricts access to user-specific subcollections.
     */
    match /users/{userId}/attendance/{attendanceId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages leave requests for a user.
     * @path /users/{userId}/leaveRequests/{leaveRequestId}
     * @allow (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 can manage their own leave requests under /users/oCZzCwBTCyZnmpizN4MZxILbVm13/leaveRequests/{leaveRequestId}
     * @deny (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot manage another user's leave requests under /users/someOtherUserId/leaveRequests/{leaveRequestId}
     * @principle Enforces document ownership and restricts access to user-specific subcollections.
     */
    match /users/{userId}/leaveRequests/{leaveRequestId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages payroll information for a user.
     * @path /users/{userId}/payroll/{payrollId}
     * @allow (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 can manage their own payroll information under /users/oCZzCwBTCyZnmpizN4MZxILbVm13/payroll/{payrollId}
     * @deny (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot manage another user's payroll information under /users/someOtherUserId/payroll/{payrollId}
     * @principle Enforces document ownership and restricts access to user-specific subcollections.
     */
    match /users/{userId}/payroll/{payrollId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages chat messages for a user.
     * @path /users/{userId}/chatMessages/{chatMessageId}
     * @allow (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 can manage their own chat messages under /users/oCZzCwBTCyZnmpizN4MZxILbVm13/chatMessages/{chatMessageId}
     * @deny (create, get, list, update, delete) User oCZzCwBTCyZnmpizN4MZxILbVm13 cannot manage another user's chat messages under /users/someOtherUserId/chatMessages/{chatMessageId}
     * @principle Enforces document ownership and restricts access to user-specific subcollections.
     */
    match /users/{userId}/chatMessages/{chatMessageId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Stores job candidates in the recruitment process.
     * @path /candidates/{candidateId}
     * @allow (get, list) Any user can read candidate information.
     * @deny (create, update, delete) No user can create, update, or delete candidate information without a validated ownership field.
     * @principle Allows public read access but restricts write access.
     */
    match /candidates/{candidateId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Stores detected anomalies in attendance records.
     * @path /anomalies/{anomalyId}
     * @allow (get, list) Any user can read anomaly information.
     * @deny (create, update, delete) No user can create, update, or delete anomaly information without a validated ownership field.
     * @principle Allows public read access but restricts write access.
     */
    match /anomalies/{anomalyId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }

  // Helper function to determine if the current user is the owner of the document.
  function isOwner(userId) {
    return isSignedIn() && request.auth.uid == userId;
  }

  // Helper function to determine if the current user is the owner of the document and it exists
  function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
  }

  // Helper function to determine if the user is signed in.
  function isSignedIn() {
    return request.auth != null;
  }
}